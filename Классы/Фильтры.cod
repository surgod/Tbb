class "Функции формирования фильтров для записей";

inclass  private

--CardName: class[] record;
FieldName1: string = 'ДатаНачала';
FieldName2: string = 'ДатаОкончания';

func SomeFieldsFilterByDates (DateB: date; DateE: date; Field1: string = FieldName1; Field2: string = FieldName2; ExtrFilter: string = nil): string;
  var НачалоВПериоде, КонецВПериоде: string;
  if ((DateB = nil) and (DateE = nil)):
      Result = ExtrFilter;
  elsif ((DateB <> nil) and (DateE = nil)): -- ограничение только на начало периода:
      НачалоВПериоде = '(' + Field1 + '<=' + Str(DateB) + ') or (' + Field1 + '=nil)'; -- дата начала не позже ограничения или не определена
      КонецВПериоде  = '(' + Field2 + '>=' + Str(DateB) + ') or (' + Field2 + '=nil)'; -- дата окончания не раньше ограничения или не определена
      Result = '(' + НачалоВПериоде + ') and (' + КонецВПериоде + ')';
      Result = '(' + Result + ') ' + if((ExtrFilter <> nil), ' and (' + ExtrFilter + ')', '');
  elsif ((DateB = nil) and (DateE <> nil)): -- ограничение только на конец периода:
      НачалоВПериоде = '(' + Field1 + '<=' + Str(DateE) + ') or (' + Field1 + '=nil)'; -- дата начала не позже ограничения или не определена
      КонецВПериоде  = '(' + Field2 + '>=' + Str(DateE) + ') or (' + Field2 + '=nil)'; -- дата окончания не раньше ограничения или не определена
      Result = '(' + НачалоВПериоде + ') and (' + КонецВПериоде + ')';
      Result = '(' + Result + ') ' + if((ExtrFilter <> nil), ' and (' + ExtrFilter + ')', '');
  elsif ((DateB <> nil) and (DateE <> nil)):
    if (DateB = DateE):
      Result = '(' + Field1 + '<=' + Str(DateB) + ' or ' + Field1 + '=nil)' + ' and ' + '(' + Field2 + '>=' + Str(DateE) + ' or ' + Field2 + '=nil)';
      Result = '(' + Result + ') ' + if((ExtrFilter <> nil), ' and (' + ExtrFilter + ')', '');
     else
      НачалоВПериоде = '(' + Field1 + '<=' + Str(DateE) + ') or (' + Field1 + '=nil)';
      КонецВПериоде  = '(' + Field2 + '>=' + Str(DateB) + ') or (' + Field2 + '=nil)';
      Result = '(' + НачалоВПериоде + ') and (' + КонецВПериоде + ')';
      Result = '(' + Result + ') ' + if((ExtrFilter <> nil), ' and (' + ExtrFilter + ')', '');
    fi;
  fi;
end;

inclass  public

--@doc Функция строкового типа, возвращающая фильтр на актуальные записи на дату запроса.
--@doc Аргумент - только дата запроса.
func ФильтрПоДате (DateB: date; Field1: string = FieldName1; Field2: string = FieldName2): string;
  Result = SomeFieldsFilterByDates(DateB, DateB, Field1, Field2);
end;

--@doc Функция строкового типа, возвращающая фильтр на записи, актуальные позднее даты запроса.
--@doc Аргумент - только дата запроса.
func ФильтрПоДатеПозднее (DateE: date; Field2: string = FieldName2): string;
  if (DateE <> nil):
    Result = '(' + Field2 + '>=' + Str(DateE) + ') or (' + Field2 + '=nil)'; -- дата окончания не раньше ограничения или не определена
  fi;
end;


--@doc Функция строкового типа, возвращающая фильтр на актуальные записи на диапазон дат запроса.
--@doc Аргументы - дата начала и дата окончания периода запроса. Под фильтр должны попадать не только
--@doc те записи, у которых период актуальности целиком ложится в диапазон дат запроса, но и те, у которых период актуальности начинается или заканчивается между датами запроса.
func ФильтрПоДатам (DateB: date; DateE: date; Field1: string = FieldName1; Field2: string = FieldName2): string;
  Result = SomeFieldsFilterByDates(DateB, DateE, Field1, Field2);
end;

--@doc Функция логического типа, определяющая актуальность конкретной записи по ссылке и дате запроса.
--@doc Аргументы: 1. Ссылка на запись. Тип записи (конкретная таблица) заранее неизвестен.
--@doc            Поэтому тип первого аргумента должен быть просто Record, а в функции необходимо
--@doc            предусмотреть проверку на наличие в тестируемой записи полей "ДатаНачала" и "ДатаОкончания".
--@doc 2. Дата запроса.
--@doc Аналогичная функция для диапазона дат.
func ЗаписьСуществуетНаДаты Synonym RecExistInDates (TheRec: record; DateB: date; DateE: date; Field1: string = FieldName1; Field2: string = FieldName2): logical;   --
  var TheFilter: string;
  var TheQuery: Query;
  TheFilter = SomeFieldsFilterByDates(DateB, DateE, Field1, Field2);--SomeFieldsFilterByDates(DateB, DateE);
  TheQuery = Query.Create;
  TheQuery.Records = [TheRec.ClassType];--CardName;
  TheQuery.LoadingFields = Field1 + ';' + Field2;
  TheQuery.Filter = TheFilter;
  Result = TheQuery.MatchFilter(TheRec);
end;

func ЗаписьСуществуетНаДату (TheRec: record; DateB: date; Field1: string = FieldName1; Field2: string = FieldName2) :logical;
  result = RecExistInDates(TheRec, DateB, DateB);
end;

 ------------- фильтры на иерархические записи -----------

--@doc Типовой фильтр
func ТолькоГруппы: string; Result = 'isGroup=-1';
end;

--@doc Типовой фильтр
func КромеГрупп: string; Result = 'isGroup<>-1';
end;


-- Добавляет GroupPath в отсортированный массив GroupPathS
-- необязательный параметр NotIn не включает в результат цепочки, входящие в другие
--  1.2.3 не попадет в результат, если есть 1.2.3.4
 func ДобавитьПутьГруппы Synonym GroupPathADD (var GroupPathS: String[]; GroupPath: String; NotIn: Logical = false): Integer;
   var j: Integer;
   if SearchNearestInArray(GroupPathS, GroupPath, j):
     return 0;-- уже есть такой GroupPath
   fi;
   if (not NotIn) or (j > LengthOfArray(GroupPathS)) or (Pos(GroupPath, GroupPathS[j]) <> 1):
     InsertInArray(GroupPathS, j, GroupPath);
     return j;
   fi;
   return 0;
 end;

-- дополняет массив GroupPathS недостающими GroupPath из запроса с фильром,
-- запрос не пересчитывается, если его фильтр совпадает с входящим RecordsFilter,
-- а режим загрузки полей, загружаемые поля, поле сортировки равны соответственно 0, "GroupPath;IsGroup;DocID", "GroupPath"
-- ! GroupPathS обязательно отсортирован в порядке возрастания или пустой!
-- необязательный параметр NotIn не включает в результат цепочки, входящие в другие
--  1.2.3 не попадет в результат, если есть 1.2.3.4
 proc ЗаполнитьПутиГрупп Synonym FillGroupPathS (var GroupPathS: String[]; Q: Query; RecordsFilter: String; NotIn: Logical = false);
   var i, j: Integer;
   var asADD: Logical;
   var groupPathOld: String;
    --внутренние функции.......................................................
    proc GroupPathOldADD;--{
      i = i + 1; -- подсчет длины массива GroupPathS
      if asADD: -- добавляем внутри массива
       j = GroupPathADD(GroupPathS, groupPathOld, NotIn);
       if i <= j and j > 0: -- начали добавлять за пределы входящего GroupPathS, можем просто добалять остальное в конец
         asADD = false;
       else
         if j < 1: -- такой уже есть, т.е. ничего не добавили
           i = i - 1;
         fi;
       fi;
      else -- простой вариант добавления в конец массива
       GroupPathS[i] = groupPathOld;
      fi;
    end;--}

    func GroupPathCurrent: string;--{
     Result = Q.Current.GroupPath;
     if Q.Current.IsGroup:
       Result = Result + '.' + str(Q.Current.DocID);
     fi;
    end;--}

   asADD = (GroupPathS <> nil);
   if Q.Filter <> RecordsFilter or Q.LoadingFieldsMode <> 0 or Q.LoadingFields <> "GroupPath;IsGroup;DocID" or Q.Order <> "GroupPath":
   -- не открываем запрос лишний раз
     if Q.Active :
       Q.Close;
     fi;
     Q.Filter = RecordsFilter;
     Q.LoadingFieldsMode = 0; -- не загружать поля
     Q.LoadingFields = "GroupPath;IsGroup;DocID";
     Q.Order = "GroupPath";
   fi;
   if Q.RecordsExists:
     i = LengthOfArray(GroupPathS);
     if not Q.Active :
       Q.Select;
     else
       Q.First;
     fi;
     groupPathOld = GroupPathCurrent;
     while not Q.EOF do
       Q.Next;
       if Q.EOF: -- добавляем последний элемент
          GroupPathOldADD;
       else
         if (NotIn and Pos(groupPathOld, GroupPathCurrent) <> 1) or (not NotIn and groupPathOld <> GroupPathCurrent):
           -- сменили значение
           GroupPathOldADD;
         fi;
         groupPathOld = Q.Current.GroupPath;
       fi;
     od;
   fi;
 end;

-- Удаляет из отсортированного по возрастанию GroupPathS цепочки, входящие в другие
 proc ПутиГруппБезВхождений Synonym GroupPathSNotIn (var GroupPathS: String[]);
   var i: Integer;
   i = LengthOfArray(GroupPathS);
   if i < 2: return; fi;
   while i > 1 do
     while Pos(GroupPathS[i - 1], GroupPathS[i]) = 1 do
       DeleteFromArray(GroupPathS, i - 1);
     od;
     i = i - 1;
   od;
 end;
  --
--@doc процедура дополняющая массив ListDocId недостающими значениями DocID, взятыми из GroupPath  - строковой цепочки DocID через точку
  proc ПутьГруппыДобавитьВСписок Synonym GroupPathAddToList(var ListDocId: Integer[]; GroupPath: String);
    var i, wcount: Integer;
    var wcurrent: Integer;
    wcount = WordsCount(GroupPath, '.');
    for i = wcount..1 step -1 do
      wcurrent = int(ExtractWord(GroupPath, i, '.'));
      if SearchInArray(ListDocId, wcurrent, ,true) < 1 then
         СИС2.Функции.ВставитьЗначениеВУпорядоченныйМассив(ListDocId, wcurrent);
      else break; -- часть ветки была отработана ранее, не отрабатываем повторы
      fi;
    od;
  end;

--@doc Функция дополняющая массив locmDocId недостающими значениями DocID, взятыми из массива таких цепочек - GroupPathS
 Proc ПутиГруппДобавитьВСписок Synonym GroupPathsAddToList(var GroupPathS: String[]; var ListDocId: Integer[]);
   var i, ii: Integer;
   ii = LengthOfArray(GroupPathS);
   for i = 1 .. ii do
     GroupPathAddToList(ListDocId, GroupPathS[i]);
   od;
 end;

--@doc процедура дополняющая целочисленный массив значениями полей DocID записей,
--@doc являющимися иерархическими предками записей, отобранными входящим фильтром
--@doc Аргументы: 1. Класс записи.
--@doc 2. фильтр на записи.
--@doc 3. массив DocID.
--@doc ! функция расчитана на использование в НЕ гетерогенных картотеках
--@doc ! при использовании в гетерогенной картотеке DocID могут повторяться для разных классов записей, что приведет к показу "пустых" ветвей
--@doc ! поэтому входящий аргумент RecordClass  - не массив
 Proc ДополнитьСписокДереваПоФильтру Synonym AddDocIDListByFilter(RecordClass: Class Record; RecordsFilter: String; var ListDocId: Integer[]);
    var groupPathS: String[];
    var q: Query;
    --внутренние функции.......................................................
    --работает по ссылочности
    proc ДополнитьМассивКлючей(R:Record);--{
      if (R.isGroup):
        СИС2.Функции.ВставитьЗначениеВУпорядоченныйМассив(ListDocId, R.DocId);
      fi;
      if (R.GroupDoc <> nil):
        if SearchInArray(ListDocId, R.GroupDoc, ,true) < 1 then -- исключаем повторный подъем по ветке
           ДополнитьМассивКлючей(R.GroupDoc);
        fi;
      fi;
    end;--}

    if RecordsFilter = nil: RecordsFilter = "isGroup<>0"; fi;
    if RecordClass.Hierarchical:
      q = Query.Create([RecordClass]);
      if ФункцииРттиСрв.ЕстьПолеВКлассеЗаписиMTL('GroupPath', RecordClass.ClassInfo):
        FillGroupPathS(groupPathS, q, RecordsFilter, true); -- исключаем при отборе внутренние пересечения
        GroupPathsAddToList(groupPathS, ListDocId);
      else
        q.Filter = RecordsFilter;
        q.LoadingFieldsMode = 0; -- не загружать поля
        q.LoadingFields = "DocId;GroupDoc";
        if q.RecordsExists:
          q.Select;
          while not q.EOF do
            ДополнитьМассивКлючей(q.Current);
            q.Next;
          od;
        fi;
      fi;
    fi;
 end;

 func СписокДереваПоФильтру Synonym DocIDListByFilter(RecordClass: Class Record; RecordsFilter: String; ListDocId: Integer[] = nil): Integer[];
   if ListDocId <> nil:
     Result = ListDocId;
   fi;
   AddDocIDListByFilter(RecordClass, RecordsFilter, Result);
 end;

--@doc Функция возвращает фильтр на поле DocID по входящему массиву значений DocID,
--@doc при пустом входящем массиве возвращает всегда ложное условие фильра
 func МассивDocIDКакФильтр Synonym ArrayDocIDAsFilter (locmDocId: Integer[] = nil) :String;
   Result = '';
   if LengthOfArray(locmDocId) > 0:
      Result = 'DocId in ' + Str(locmDocId);
   else
      Result = 'DocId in [0]';
   fi;
 end;

--@doc Функция возвращает фильтр на дерево иерархической записи на основании фильтра на данные - RecordsFilter
--@doc выбирает и пустые ветки
--@doc при пустом фильре на данные выбирает все дерево, включая пустые ветки
 func ПолучитьФильтрДереваПоФильтру Synonym GetFilterTreeByFilter(Records: Class[] Record; RecordsFilter: String): String;
   var i, ii: Integer;
   var filterAll: String[];
   filterAll = nil;
   if Records <> nil:
     if RecordsFilter = nil:
       filterAll[1] = "IsGroup <> 0"; -- восстанавливаем все дерево, включая пустые ветки
     else
       ii = LengthOfArray(Records);
       for i = 1..ii do
         filterAll[i] = ArrayDocIDAsFilter(СписокДереваПоФильтру(Records[i], RecordsFilter));
         if ii > 1: -- при гетерогенном варианте добавляем условие на текущий класс записи
           filterAll[i] = СИС2.СтроковыеФункции.СложитьСтрокиФильтраПоИ([filterAll[i], "classtype = " + Records[i].ClassProject+'.'+Records[i].ClassName]);
         fi;
       od;
     fi;
     Result = СИС2.СтроковыеФункции.СложитьСтрокиФильтраПоИли(filterAll);
   fi;
 end;

--@doc Функция возвращает фильтр на дерево иерархической записи на основании фильтра на данные - RecordsFilter
--@doc выбирает не пустые ветки
--@doc при пустом фильре на данные выбирает все дерево, включая пустые ветки
 func ПолучитьФильтрДереваПоФильтруНаДанные Synonym GetFilterTreeByFilterRecord(Records: Class[] Record; RecordsFilter: String): String;
   if Records <> nil:
     if RecordsFilter <> nil:
       RecordsFilter = СИС2.СтроковыеФункции.СложитьСтрокиФильтраПоИ([RecordsFilter, "IsGroup=0 and GroupPath<>nil"]);
     fi;
     Result = ПолучитьФильтрДереваПоФильтру(Records, RecordsFilter);
   fi;
 end;

 func МаксИерархия synonym MaxHierarchy (RecordClass: Class Record; ExistGroupPath: Logical = true): Integer;
 var q: Query;
    q = Query.Create([RecordClass]);
    while q.RecordsExists do
     result = result + 1;
     if ExistGroupPath then
        q.filter = 'match(GroupPath,"*?'+RepStr('.?*',result) + '")';
     else
        q.filter = 'GroupDoc'+RepStr('.GroupDoc',result) + '=nil';
     end;
    od;
    if not ExistGroupPath then result = result - 1; fi;
 end;

 func УровеньВложенности synonym LevelRecord (R: Record; ExistGroupPath: Logical = true): Integer;
   if R <> nil:
     if  ExistGroupPath then return WordsCount(R.GroupPath, '.'); fi;
     while R.GroupDoc <> nil do
       Result = Result + 1;
       R = R.GroupDoc;
     end;
   fi;
 end;

 -- методы, повторяющие одноименные в базовых проектах ДИЦ --

 func СложитьСтрокиФильтраПоИ (locFlt: String[]): String;
   Return СИС2.СтроковыеФункции.СложитьСтрокиФильтраПоИ(locFlt);
 end;

 func СложитьСтрокиФильтраПоИЛИ (locFlt: String[]; ИгнорироватьПустуюСтроку: Logical = true): String;
   Return СИС2.СтроковыеФункции.СложитьСтрокиФильтраПоИЛИ(locFlt, ИгнорироватьПустуюСтроку);
 end;


end
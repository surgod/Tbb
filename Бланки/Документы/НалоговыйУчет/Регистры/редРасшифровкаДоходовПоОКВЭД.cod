class inherited НалогУчет.Документы.НалоговыйУчет.Регистры_Автозаполнение.редБазовыйРегистр "Расшифровка доходов по ОКВЭД", editor НалоговыйУчет.Регистры.РасшифровкаДоходовПоОКВЭД;
import СИС2 classes СтроковыеФункции, Календарь, ФункцииДокумента, Константы;

inclass private

type тКолонкиОтчета = (тДата = 1, тКонтрагент, тНомер, тСуммаВсего, тСумма6201, тСумма6202, тСумма6209, тСумма4651, тСуммаДР1, тСуммаДР2);
type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд, тПтОКВЭД);
type тРезультатСравнения = (тМеньше = 1, тРавно, тБольше);

var КодыЭД: variant[2] = [["62.01", тСумма6201], ["62.02", тСумма6202], ["62.09", тСумма6209], ["46.51", тСумма4651]];
var ПоляПодтаблицы: string[] = ["ДатаДокумента", "РеквП", "НомерБум", "Сумма", "ВидЭд", "Сумма", "ОКВЭД"];
stored var ТолькоВЭД: logical;

inobject private

var СуммаПоз: numeric[]; --

var РаспределениеВЭД: тКолонкиОтчета[]; -- распределение ВЭД по колонкам отчета

var ВидЭД: Subtable; -- подтаблица видов ЭД

var СуммыПоКолонкам: variant[2];

--НалоговыйУчет.Регистры.РасшифровкаДоходовПоОКВЭД
--    struct Позиции array integer title "Список операций";
--      field БанковскаяВыписка :Бухучет.Банки.Выписки title "Банковская выписка";
--      field Контрагент        :Базовый.Данные.Субъект title "Контрагент";
--      field РеквП             :Базовый.Данные.Субъект title "Реквизиты контрагента";
--      field ПрихПлатПоручение :Первичка.Банки.ПрихПлПоручения title "Прих.платежное поручение";
--      field ПервДок           :Первичка.Банки.ПрихПлПоручения title "Первичный документ";
--      field КорСчет           :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--      field Банк              :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--      field ДатаДокумента     :date title "Дата первичного документа";
--      field НомерБум          :string title "Номер, первичного документа";
--      field НомВыпД           :string title "Номер строки в выписке банка";
--      field Т                 :string(350) title "Назначение платежа";
--      field Сумма             :real title "СуммаСумма операции";
--      field ОКВЭД             :Классификаторы.ОКВЭД2 title "Признак ОКВЭД";
--      field КодОп             :string title "Корреспондирующий счет";
--   end;

--  struct ПозицииДеб array Integer;
--    field Проводить         :Logical                                 title "Формировать операцию по текущей позиции";
--    field НомВыпД           :String                                  title "Номер строки в выписке банка";
--
--    field ДатаДокумента     :Date                                    title "Дата платежного документа";
--    field НомерБум          :String                                  title "Номер, указанный в выписке банка";
--
--    field РеквП             :Базовый.Данные.Субъект                  title "Реквизиты контрагента";
--    field Сумма             :Numeric                                 title "Сумма платежа";
--    field КодОп             :String                                  title "Корреспондирующий счет";
--
--    field АвСчетФактура     :Первичка.УчетНДС.СчетаФактуры;
--    field КорСчет           :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--    field Т                 :String(350)                             title "Назначение платежа";
--
--    field ПрихПлатПоручение :Первичка.Банки.ПрихПлПоручения;
--
--    struct ДопПараметры array Integer;
--      field Название       :String;
--      field Значение       :inherited СИС2.Базовая.БазоваяЗапись;
--      field Расщепление    :Integer;
--    end;
--  end;

--{ вспомогательые методы
--@doc строковое представление даты в виде "__" ________ YY__  с макросами поля
func ДатаВСтрокуСМакро(locDate:Date): string;
  result = format('"<u+>%d<u->" <u+>%s<u-> %d<u+>%d<u->',
                  [day(locDate), Месяца(Mon(locDate)), div(year(locDate), 100), mod(year(locDate), 100)]);
end;

--@doc проверка входных параметров
func ПараметрыКорректны: logical;
  if Рекв = nil:
  elsif Период = nil:
   Message("Укажите отчетный период!");
   Self.Template.Field = "Период.ДатаНачала";
  else
    result = true;
  fi;
end;

--@doc заполнение бланка
proc Заполнитьбланк;
  var q: Query;
  var iter: integer;
  --var iter, isub, irec: integer;
  var локКлонкаПодтаблицы: тКолонкиПодтаблицы;
  var aFiler: string[];
  --var ares: variant[2];
  var мПозиция: variant[];
  --var locDate: Date;
  --var locNum, locT, locExtId: string;
  --var locRekv: Базовый.Данные.Субъект;
  --var locSub: structure;
  if РаспределениеВЭД = nil:
    РаспределитьОКВЭДпоКолонкам;
  fi;

  --ares = nil;


  aFiler[1] = "Проводить";
  --aFiler[2] = "ПозицииДеб.Проводить";
  aFiler[3] = "ДатаПроведения>01.01.1900";
--  --aFiler[4] = "ПозицииДеб.Дата>=" + str(Период.ДатаНачала);
--  --aFiler[5] = "ПозицииДеб.Дата<=" + str(Период.ДатаОкончания);
  aFiler[4] = "ДатаПроведения>=" + str(Период.ДатаНачала);
  aFiler[5] = "ДатаПроведения<=" + str(Период.ДатаОкончания);
  aFiler[6] = "Рекв=" + str(Рекв);
  q = Query.Create([Бухучет.Банки.Выписки]);
  try
    q.LoadingFieldsMode = mdAll + mdStructArrays;
    q.LoadingFields = "ExtId;Проводить;ДатаПроведения;Рекв;ПозицииДеб;ПозицииДеб.Проводить;ПозицииДеб.ДатаДокумента;ПозицииДеб.НомерБум;ПозицииДеб.РеквП;ПозицииДеб.Т;ПозицииДеб.ВидЭд.ОКВЭД;ПозицииДеб.ВидЭд.Сумма";
    q.Filter = СложитьстрокиФильтраПоИ(aFiler);
    if q.Count > 0:
      --q.Order = "ПозицииДеб.ДатаДокумента;ПозицииДеб.РеквП;ПозицииДеб.НомерБум;ПозицииДеб.ВидЭд.ОКВЭД";
      q.Select;

--type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд, тПтОКВЭД);
--type тРезультатСравнения = (тМеньше = 1, тРавно, тБольше);
--
--var КодыЭД: variant[2] = [["62.01", тСумма6201], ["62.02", тСумма6202], ["62.09", тСумма6202], ["46.51", тСумма4651]];
--var ПоляПодтаблицы: string[] = ["ДатаДокумента", "РеквП", "НомерБум", "Сумма", "ВидЭд", "Сумма", "ОКВЭД"];

--proc ДобавитьВОтчет(мПозиция: variant[]);
----type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд);
      if not RecordEdited(Self.Record):
        ValidRecordEdit(Self.Record);
      fi;
      if RecordEdited(Self.Record):
        if Позиции.Count > 0:
          Позиции.Clear;
        fi;
        while not q.Eof do
          --locSub = q.Current.ПозицииДеб;
          for iter = 1 .. q.Current.ПозицииДеб.Count do
            for локКлонкаПодтаблицы = тПтДата .. тПтВидЭд do
             мПозиция[локКлонкаПодтаблицы] = q.Current.ПозицииДеб.Items[iter].GetField(ПоляПодтаблицы[локКлонкаПодтаблицы]);
            end;
            if not ТолькоВЭД or мПозиция[тПтВидЭд].count > 0:
              ДобавитьВОтчет(мПозиция);
            fi;
          od;
          q.Next;
        od;
      else
        seterror(-1,"Не внести изменения в документ!", "Ошибка:", itError);
      fi;
    else
      message('Нет данных для занесения в регистр!');
    fi;
  finally
    q = nil;
  end;
  ПолучитьСуммыПоКолонкам;
--  if ТолькоВЭД:
--    iter = 1;
--    while  iter <= Позиции.Count do
--      if ВзятьСуммуПоколонкам(iter) = 0:
--        Позиции.delete(iter);
--        locSub = Позиции.items[iter];
--      else
--        iter = iter + 1;
--      fi;
--    od;
--  fi;

--  if vartype(ares) = varArray and LengthOfArray(ares)>0:
--    if not RecordEdited(Self.Record):
--      ValidRecordEdit(Self.Record);
--    fi;
--    if RecordEdited(Self.Record):
--      if Позиции.Count > 0:
--        Позиции.Clear;
--      fi;
--      for iter = 1 .. LengthOfArray(ares[1]) do
----          locExtId = ares[1, iter];
----          locDate = ares[2, iter];
----          locNum = ares[3, iter];
----          locRekv = ares[4, iter];
----          locT = ares[5, iter];
--        if locDate <> ares[1, iter] or locNum <> ares[2, iter] or
--           locRekv <> ares[3, iter] or locT <> ares[4, iter]:
--          locExtId = ares[1, iter];
--          locDate = ares[2, iter];
--          locNum = ares[3, iter];
--          locRekv = ares[4, iter];
--          locT = ares[5, iter];
--          isub = Позиции.Count+1;
--          Позиции.Insert(isub);
--          Позиции[isub].БанковскаяВыписка =QueryRecord(Бухучет.Банки.Выписки, "ExtId='" + locExtId +"'");
--          Позиции[isub].Контрагент        =locRekv;
--          Позиции[isub].РеквП             =locRekv;
--          --Позиции[isub].ПрихПлатПоручение = nil;
--          --Позиции[isub].ПервДок           = nil;
--          --Позиции[isub].КорСчет           = nil;
--          --Позиции[isub].Банк              = nil;
--          --Позиции[isub].КодОп             = "";
--          --Позиции[isub].НомВыпД           = "";
--          Позиции[isub].ДатаДокумента     = locDate;
--          Позиции[isub].НомерБум          = locNum;
--          Позиции[isub].Т                 = locT;
--        fi;
--        with Позиции[isub].ВидЭД do
--          with Insert(Count + 1) do
--            ОКВЭД = ares[6, iter]; -- Позиции[isub].ВидЭД[].ОКВЭД
--            Сумма = ares[7, iter]; -- Позиции[isub].ВидЭД[].Сумма
--          od;
--        od;
--      od;
--    else
--      seterror(-1,"Не внести изменения в документ!", "Ошибка:", itError);
--    fi;
--  fi;
end;


--@doc получить величину для сравнения
func ДляСравнения(ПоКолонке: тКолонкиПодтаблицы; Значение: variant): variant;
  if ПоКолонке = тПтКонтрагент:
    if Значение <> nil:
      result = Значение.Имя;
    else
      result = "";
    fi;
  elsif ПоКолонке = тПтОКВЭД:
    if Значение <> nil:
      result = Значение.Код;
    else
      result = "";
    fi;
  else
    result = Значение;
  fi;
end;

--@doc сравнение поля подтаблицы со значением
func Сравнить(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; Индекс: integer): тРезультатСравнения;
  var ЗначениеИзПодтаблицы, ЗначениеПараметр: variant;
  if ПоКолонке = тПтОКВЭД:
    ЗначениеИзПодтаблицы = ДляСравнения(ПоКолонке, ВидЭД.Items[Индекс].GetField(ПоляПодтаблицы[ПоКолонке]));
  else
    ЗначениеИзПодтаблицы = ДляСравнения(ПоКолонке, Позиции.Items[Индекс].GetField(ПоляПодтаблицы[ПоКолонке]));
  fi;
  ЗначениеПараметр = ДляСравнения(ПоКолонке, Значение);
  if ЗначениеПараметр < ЗначениеИзПодтаблицы:
    return тМеньше;
  elsif ЗначениеПараметр = ЗначениеИзПодтаблицы:
    return тРавно;
  else
    return тБольше;
  fi;
end;

--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение для сохранения упорядоченности
func НайтиБыстроВПодтаблице(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; от: integer; до: integer): Integer;
  var РезультатСравнения: тРезультатСравнения;
  var середина: integer;
  if до = 0:
    result = - 1;
  elsif от > до:
    result = - (до + 1);
  elsif от = до:
    РезультатСравнения = Сравнить(ПоКолонке, Значение, от);
    if РезультатСравнения = тМеньше:
      result = - от;
    elsif РезультатСравнения = тРавно:
      result = от;
    else
      result = - (от + 1);
    fi;
  elsif от + 1 = до:
    result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, от, от);
    if result < 0 and - result > от:
      result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, до, до);
    fi;
  else
    середина = от + int((до - от)/2);
    result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, от, середина);
    if result < 0 and - result > середина:
      result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, середина + 1, до);
    fi;
  fi;
end;

--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение для сохранения упорядоченности
func НайтиВПодтаблице(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; от: integer; до: integer): Integer;
  var iter: integer;
  var РезультатСравнения: тРезультатСравнения;
  iter = от;
  while iter <= до do
    РезультатСравнения = Сравнить(ПоКолонке, Значение, iter);
    if РезультатСравнения = тРавно:
      result = iter;
      break;
    elsif РезультатСравнения = тМеньше:
      result = - iter;
      break;
    fi;
    iter = iter + 1;
  od;
  if iter > до:
    result = - iter;
  fi;
end;

--@doc добавление данных в отчет
proc ДобавитьВОтчет(мПозиция: variant[]);
--type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд);
  var iter: тКолонкиПодтаблицы;
  var index, ifrom, ito, indexsub, itersub: integer;
  var ЗначениеИзПодтаблицы: variant;
  ifrom = 1;
  ito = Позиции.Count;
  for iter = тПтДата .. тПтНомер do
    index = НайтиБыстроВПодтаблице(iter, мПозиция[iter], ifrom, ito);
    --index = НайтиВПодтаблице(iter, мПозиция[iter], ifrom, ito);
    if index < 0:
      break;
    else
      ЗначениеИзПодтаблицы = ДляСравнения(iter, Позиции.Items[index].GetField(ПоляПодтаблицы[iter]));
      ifrom = index;
      index = index + 1;
      while index <= ito  do
        if ЗначениеИзПодтаблицы <> ДляСравнения(iter, Позиции.Items[index].GetField(ПоляПодтаблицы[iter])):
          ito = index - 1;
          break;
        else
          index = index + 1;
        fi;
      od;
    fi;
  od;
  if index < 0:
    index = - index;
    Позиции.Insert(index);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтДата], мПозиция[тПтДата]);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтКонтрагент], мПозиция[тПтКонтрагент]);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтНомер], мПозиция[тПтНомер]);
  fi;
  Позиции.Items[index].Сумма = Позиции.Items[index].Сумма + мПозиция[тПтСуммаВсего];
  ВидЭД = Позиции.Items[index].ВидЭД;
  for itersub = 1 .. мПозиция[тПтВидЭд].Count do
   indexsub = НайтиВПодтаблице(тПтОКВЭД, мПозиция[тПтВидЭд].Items[itersub].ОКВЭД, 1, ВидЭД.Count);
   if indexsub < 0:
     indexsub = - indexsub;
     ВидЭД.Insert(indexsub);
     ВидЭД.items[indexsub].ОКВЭД = мПозиция[тПтВидЭд].Items[itersub].ОКВЭД;
   fi;
   ВидЭД.items[indexsub].Сумма = ВидЭД.items[indexsub].Сумма + мПозиция[тПтВидЭд].Items[itersub].Сумма;
  od;
end;

---@doc распределение оКВЭД по колонкам отчета
proc РаспределитьОКВЭДпоКолонкам;
var locRec: Классификаторы.ОКВЭД2;
var iter: integer;
 РаспределениеВЭД = nil;
 for iter = 1 .. LengthOfArray(КодыЭД) do
   locRec = QueryRecord(Классификаторы.ОКВЭД2, format("КОД='%s'", [КодыЭД[iter, 1]]), , "DocId;GroupPath");
   if locRec <> nil:
     РаспределениеВЭД[locRec.DocId]= КодыЭД[iter, 2] as тКолонкиОтчета;
     with Query.Create([Классификаторы.ОКВЭД2]) do
       LoadingFields = "DocId";
       LoadingFieldsMode = mdNone;
       Filter = format("pos('%s%d.',GroupPath)=1",[locRec.GroupPath, locRec.DocId]);
       Select;
       while not Eof do
         РаспределениеВЭД[Current.DocId]= КодыЭД[iter, 2] as тКолонкиОтчета;
         next;
       od;
     end;
   fi;
 od;
end;

func ПолучитьСуммуПоВЭД(Index: integer; тКолонка: тКолонкиОтчета): Numeric;
  var iter: integer;
  var ВидЭД: SubTable;
  if VarType(СуммыПоКолонкам[index, тКолонка]) <> varNumeric:
    ВидЭД = Позиции.Items[index].ВидЭД;
    for iter = 1 .. ВидЭД.Count do
      if тКолонка <> тСуммаДР1:
        if РаспределениеВЭД[ВидЭД.items[iter].ОКВЭД.DocID] = тКолонка:
          result = result + ВидЭД.items[iter].Сумма;
        fi;
      elsif РаспределениеВЭД[ВидЭД.items[iter].ОКВЭД.DocID] = nil:
        result = result + ВидЭД.items[iter].Сумма;
      fi;
    od;
    СуммыПоКолонкам[index, тКолонка] = result;
  else
   result = СуммыПоКолонкам[index, тКолонка];
  fi;
end;

func ПроверитьСуммыПоКолонке(тКолонка: тКолонкиОтчета): logical;
  var index: integer;
  result = true;
  for index = 1 .. Позиции.Count do
    if VarType(СуммыПоКолонкам[index, тКолонка]) <> varNumeric:
      result = false;
      break;
    fi;
  od;
end;

proc ПолучитьСуммыПоКолонке(тКолонка: тКолонкиОтчета);
  var index: integer;
  for index = 1 .. Позиции.Count do
    ПолучитьСуммуПоВЭД(index, тКолонка);
  od;
end;

proc ПолучитьСуммыПоКолонкам;
  var тКолонка: тКолонкиОтчета;
  var index: integer;
  СуммыПоКолонкам = nil;
  for index = 1 .. Позиции.Count do
    for тКолонка = тСумма6201 .. тСуммаДР1 do
      ПолучитьСуммуПоВЭД(index, тКолонка);
    od;
  od;
end;

func ВзятьСуммуВсегоПоКолонке(тКолонка: тКолонкиОтчета): numeric;
  if not ПроверитьСуммыПоКолонке(тКолонка):
    ПолучитьСуммыПоКолонке(тКолонка);
  fi;
  result = sumofarray(СуммыПоКолонкам, ,[тКолонка as integer]);
end;

func ВзятьПроцВсегоПоКолонке(тКолонка: тКолонкиОтчета): numeric;
  var тТекКол: тКолонкиОтчета;
  var локСуммаВсего, локСуммаКол, локСумма: numeric;
  for тТекКол = тСумма6201 .. тСуммаДР1 do
    локСумма = ВзятьСуммуВсегоПоКолонке(тТекКол);
    локСуммаВсего = локСуммаВсего + локСумма;
    if тТекКол = тКолонка:
      локСуммаКол = локСумма;
    fi;
  od;
  if локСуммаВсего <> 0:
   result = локСуммаКол / локСуммаВсего * 100;
  else
    result = 0;
  fi;
end;

func ВзятьСуммуПоКолонкам(index: integer): numeric;
  var тТекКол: тКолонкиОтчета;
  for тТекКол = тСумма6201 .. тСуммаДР1 do
    result = ПолучитьСуммуПоВЭД(index, тТекКол) + result;
  od;
end;

func ВзятьСуммуВсегоПоКолонкам: numeric;
  var тТекКол: тКолонкиОтчета;
  for тТекКол = тСумма6201 .. тСуммаДР1 do
    result = ВзятьСуммуВсегоПоКолонке(тТекКол) + result;
  od;
end;

--@ очистка вспомогательных массивов
proc ОчиститьДоп;
 СуммыПоКолонкам = nil;
end;

--}

--{ Обработчики событий бланка

  proc шаблон_ПриОткрытии(Create :Logical);
    if РаспределениеВЭД = nil:
      РаспределитьОКВЭДпоКолонкам;
    fi;
    ПолучитьСуммыПоКолонкам;
    inherited шаблон_ПриОткрытии(Create);
  end;

--}

--{ Обработчики событий объектов бланка

proc кнРасчет(Sender :Button);
  if ПараметрыКорректны:
    Заполнитьбланк;
  fi;
end;

--}

--{ Обработчики событий полей бланка

func ПолеПериодРасчета_ПриПроверке(Cell :TemplateCell; Index :Integer;
  var Value :Variant) :Logical;
  Result = inherited ПолеПериодРасчета_ПриПроверке(Cell, Index, Value);
  if Период <> value and Позиции.Count = 0:
    ОчиститьДоп;
  fi;
end;

func Поле_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  if Cell.Contents in ["Сумма1", "Сумма2", "Сумма3", "Сумма4", "Сумма5"]:
    result = ПолучитьСуммуПоВЭД(Cell.Row, Cell.Column as тКолонкиОтчета);
  elsif Cell.Contents in ["СуммаВсего1", "СуммаВсего2", "СуммаВсего3", "СуммаВсего4", "СуммаВсего5"]:
--    if not ПроверитьСуммыПоКолонке(Cell.Column as тКолонкиОтчета):
--      ПолучитьСуммыПоКолонке(Cell.Column as тКолонкиОтчета);
--    fi;
--    result = sumofarray(СуммыПоКолонкам, ,[Cell.Column]);
    result = ВзятьСуммуВсегоПоКолонке(Cell.Column as тКолонкиОтчета);
  elsif Cell.Contents = "СуммаВсего":
    result = Позиции.SumOfField("Сумма");
  elsif Cell.Contents in ["ПроцВсего1", "ПроцВсего2", "ПроцВсего3", "ПроцВсего4", "ПроцВсего5"]:
    result = ВзятьПроцВсегоПоКолонке(Cell.Column as тКолонкиОтчета);
  else
    Result = Value; -- Что получили, то и выводим
  fi;
end;

func ПолеПериодРасчета_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  if Cell.Contents = "Период.ДатаНачала":
    Cell.UseMacro = true;
    result = "c " + ДатаВСтрокуСМакро(Период.ДатаНачала);
  elsif Cell.Contents = "Период.ДатаОкончания":
    Cell.UseMacro = true;
    result = "по " + ДатаВСтрокуСМакро(Период.ДатаОкончания);
  else
    result = inherited ПолеПериодРасчета_ПриВыводе(Cell, Value, Action, Format);
  fi;
end;

func ПолеДата_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  Cell.UseMacro = true;
  result = ДатаВСтрокуСМакро(Value);
end;

proc ПолеПриРисовании(Cell :TemplateCell; Selected :Logical;
  var Color :Integer; var FieldColor :Integer; Font :Font);
  if Cell.Contents = "Сумма":
    if Позиции.items[Cell.Row].Сумма <> ВзятьСуммуПоКолонкам(Cell.Row):
      font.Color = СИС2.Константы.clRed;
      font.Bold = true;
    fi;
  elsif Cell.Contents = "СуммаВсего":
    if round(Позиции.SumOfField("Сумма"),2) <> round(ВзятьСуммуВсегоПоКолонкам,2):
    --if Позиции.SumOfField("Сумма") <> ВзятьСуммуВсегоПоКолонкам:
--      trace("ВзятьСуммуВсегоПоКолонкам=" + str(ВзятьСуммуВсегоПоКолонкам,"#.000000"));
--      trace("Позиции.SumOfField(Сумма)=" + str(Позиции.SumOfField("Сумма"),"#.000000"));
      font.Color = СИС2.Константы.clRed;
      font.Bold = true;
    fi;
  fi;
end;

--}

end
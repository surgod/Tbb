class inherited НалогУчет.Документы.НалоговыйУчет.Регистры_Автозаполнение.редБазовыйРегистр "Расшифровка доходов по ОКВЭД", editor НалоговыйУчет.Регистры.РасшифровкаДоходовПоОКВЭД;
import СИС2 classes СтроковыеФункции, Календарь, ФункцииДокумента, Константы;

inclass private

type тКолонкиОтчета = (тДата = 1, тКонтрагент, тНомер, тСуммаВсего, тСумма6201, тСумма6202, тСумма6209, тСумма4651, тСуммаДР1, тСуммаДР2);
type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд, тПтОКВЭД);
type тРезультатСравнения = (тМеньше = 1, тРавно, тБольше);

var КодыЭД: variant[2] = [["62.01", тСумма6201], ["62.02", тСумма6202], ["62.09", тСумма6202], ["46.51", тСумма4651]];
var ПоляПодтаблицы: string[] = ["ДатаДокумента", "РеквП", "НомерБум", "Сумма", "ВидЭд", "Сумма", "ОКВЭД"];

inobject private

--БанковскаяВыписка.НомерБум,
--БанковскаяВыписка.ДатаПроведения
var СуммаПоз: numeric[]; --

var r: Бухучет.Банки.Выписки;
--var СтрокиОтчета: variant[2]; -- позиции отчета
var РаспределениеВЭД: тКолонкиОтчета[]; -- распределение ВЭД по колонкам отчета

var ВидЭД: Subtable; -- подтаблиа видов ЭД


--НалоговыйУчет.Регистры.РасшифровкаДоходовПоОКВЭД
--    struct Позиции array integer title "Список операций";
--      field БанковскаяВыписка :Бухучет.Банки.Выписки title "Банковская выписка";
--      field Контрагент        :Базовый.Данные.Субъект title "Контрагент";
--      field РеквП             :Базовый.Данные.Субъект title "Реквизиты контрагента";
--      field ПрихПлатПоручение :Первичка.Банки.ПрихПлПоручения title "Прих.платежное поручение";
--      field ПервДок           :Первичка.Банки.ПрихПлПоручения title "Первичный документ";
--      field КорСчет           :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--      field Банк              :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--      field ДатаДокумента     :date title "Дата первичного документа";
--      field НомерБум          :string title "Номер, первичного документа";
--      field НомВыпД           :string title "Номер строки в выписке банка";
--      field Т                 :string(350) title "Назначение платежа";
--      field Сумма             :real title "СуммаСумма операции";
--      field ОКВЭД             :Классификаторы.ОКВЭД2 title "Признак ОКВЭД";
--      field КодОп             :string title "Корреспондирующий счет";
--   end;

--  struct ПозицииДеб array Integer;
--    field Проводить         :Logical                                 title "Формировать операцию по текущей позиции";
--    field НомВыпД           :String                                  title "Номер строки в выписке банка";
--
--    field ДатаДокумента     :Date                                    title "Дата платежного документа";
--    field НомерБум          :String                                  title "Номер, указанный в выписке банка";
--
--    field РеквП             :Базовый.Данные.Субъект                  title "Реквизиты контрагента";
--    field Сумма             :Numeric                                 title "Сумма платежа";
--    field КодОп             :String                                  title "Корреспондирующий счет";
--
--    field АвСчетФактура     :Первичка.УчетНДС.СчетаФактуры;
--    field КорСчет           :Базовый.Справочники.БанковскиеРеквизиты title "Банковские реквизиты";
--    field Т                 :String(350)                             title "Назначение платежа";
--
--    field ПрихПлатПоручение :Первичка.Банки.ПрихПлПоручения;
--
--    struct ДопПараметры array Integer;
--      field Название       :String;
--      field Значение       :inherited СИС2.Базовая.БазоваяЗапись;
--      field Расщепление    :Integer;
--    end;
--  end;

--{ вспомогательые методы
--@doc строковое представление даты в виде "__" ________ YY__  с макросами поля
func ДатаВСтрокуСМакро(locDate:Date): string;
  result = format('"<u+>%d<u->" <u+>%s<u-> %d<u+>%d<u->',
                  [day(locDate), Месяца(Mon(locDate)), div(year(locDate), 100), mod(year(locDate), 100)]);
end;

--@doc проверка входных параметров
func ПараметрыКорректны: logical;
  if Рекв = nil:
  elsif Период = nil:
   Message("Укажите отчетный период!");
   Self.Template.Field = "Период.ДатаНачала";
  else
    result = true;
  fi;
end;

--@doc заполнение бланка
--proc Заполнитьбланк1;
--  var q: Query;
--  var iter, isub: integer;
--  var aFiler: string[];
--  var ares: variant[2];
--  var locDate: Date;
--  var locNum, locT, locExtId: string;
--  var locRekv: Базовый.Данные.Субъект;
--  aFiler[1] = "Проводить";
--  --aFiler[2] = "ПозицииДеб.Проводить";
--  aFiler[3] = "ДатаПроведения>01.01.1900";
----  --aFiler[4] = "ПозицииДеб.Дата>=" + str(Период.ДатаНачала);
----  --aFiler[5] = "ПозицииДеб.Дата<=" + str(Период.ДатаОкончания);
--  aFiler[4] = "ДатаПроведения>=" + str(Период.ДатаНачала);
--  aFiler[5] = "ДатаПроведения<=" + str(Период.ДатаОкончания);
--  aFiler[6] = "Рекв=" + str(Рекв);
--  q = Query.Create([Бухучет.Банки.Выписки]);
--  try
--    q.LoadingFieldsMode = mdAll + mdStructArrays;
--    q.LoadingFields = "ExtId;Проводить;ДатаПроведения;Рекв;ПозицииДеб;ПозицииДеб.Проводить;ПозицииДеб.ДатаДокумента;ПозицииДеб.НомерБум;ПозицииДеб.РеквП;ПозицииДеб.Т;ПозицииДеб.ВидЭд.ОКВЭД;ПозицииДеб.ВидЭд.Сумма";
--    q.Filter = СложитьстрокиФильтраПоИ(aFiler);
--    if q.Count > 0:
----      ares = q.CalcAggregates("GroupBy(ExtId)," +
----                              "GroupBy(ПозицииДеб.ДатаДокумента)," +
----                              "GroupBy(ПозицииДеб.НомерБум)," +
----                              "GroupBy(ПозицииДеб.РеквП)," +
----                              "GroupBy(ПозицииДеб.Т)," +
----                              "GroupBy(ПозицииДеб.ВидЭд.ОКВЭД),Sum(ПозицииДеб.ВидЭд.Сумма)") as variant[2];
--      q.Select;
--      ares = q.CalcAggregates("GroupBy(ПозицииДеб.НомерБум)")   as variant[2];
--    else
--      message('Нет данных для занесения в регистр!');
--    fi;
--  finally
--    q = nil;
--  end;
--  if vartype(ares) = varArray and LengthOfArray(ares)>0:
--    if not RecordEdited(Self.Record):
--      ValidRecordEdit(Self.Record);
--    fi;
--    if RecordEdited(Self.Record):
--      if Позиции.Count > 0:
--        Позиции.Clear;
--      fi;
--      for iter = 1 .. LengthOfArray(ares[1]) do
----          locExtId = ares[1, iter];
----          locDate = ares[2, iter];
----          locNum = ares[3, iter];
----          locRekv = ares[4, iter];
----          locT = ares[5, iter];
--        if locDate <> ares[1, iter] or locNum <> ares[2, iter] or
--           locRekv <> ares[3, iter] or locT <> ares[4, iter]:
--          locExtId = ares[1, iter];
--          locDate = ares[2, iter];
--          locNum = ares[3, iter];
--          locRekv = ares[4, iter];
--          locT = ares[5, iter];
--          isub = Позиции.Count+1;
--          Позиции.Insert(isub);
--          Позиции[isub].БанковскаяВыписка =QueryRecord(Бухучет.Банки.Выписки, "ExtId='" + locExtId +"'");
--          Позиции[isub].Контрагент        =locRekv;
--          Позиции[isub].РеквП             =locRekv;
--          --Позиции[isub].ПрихПлатПоручение = nil;
--          --Позиции[isub].ПервДок           = nil;
--          --Позиции[isub].КорСчет           = nil;
--          --Позиции[isub].Банк              = nil;
--          --Позиции[isub].КодОп             = "";
--          --Позиции[isub].НомВыпД           = "";
--          Позиции[isub].ДатаДокумента     = locDate;
--          Позиции[isub].НомерБум          = locNum;
--          Позиции[isub].Т                 = locT;
--        fi;
--        with Позиции[isub].ВидЭД do
--          with Insert(Count + 1) do
--            ОКВЭД = ares[6, iter]; -- Позиции[isub].ВидЭД[].ОКВЭД
--            Сумма = ares[7, iter]; -- Позиции[isub].ВидЭД[].Сумма
--          od;
--        od;
--      od;
--    else
--      seterror(-1,"Не внести изменения в документ!", "Ошибка:", itError);
--    fi;
--  fi;
--end;

--@doc заполнение бланка
proc Заполнитьбланк;
  var q: Query;
  var iter: integer;
  --var iter, isub, irec: integer;
  var локКлонкаПодтаблицы: тКолонкиПодтаблицы;
  var aFiler: string[];
  --var ares: variant[2];
  var мПозиция: variant[];
  --var locDate: Date;
  --var locNum, locT, locExtId: string;
  --var locRekv: Базовый.Данные.Субъект;
  var locSub: Бухучет.Банки.Выписки.ПозицииДеб;
  if РаспределениеВЭД = nil:
    РаспределитьОКВЭДпоКолонкам;
  fi;

  --ares = nil;


  aFiler[1] = "Проводить";
  --aFiler[2] = "ПозицииДеб.Проводить";
  aFiler[3] = "ДатаПроведения>01.01.1900";
--  --aFiler[4] = "ПозицииДеб.Дата>=" + str(Период.ДатаНачала);
--  --aFiler[5] = "ПозицииДеб.Дата<=" + str(Период.ДатаОкончания);
  aFiler[4] = "ДатаПроведения>=" + str(Период.ДатаНачала);
  aFiler[5] = "ДатаПроведения<=" + str(Период.ДатаОкончания);
  aFiler[6] = "Рекв=" + str(Рекв);
  q = Query.Create([Бухучет.Банки.Выписки]);
  try
    q.LoadingFieldsMode = mdAll + mdStructArrays;
    q.LoadingFields = "ExtId;Проводить;ДатаПроведения;Рекв;ПозицииДеб;ПозицииДеб.Проводить;ПозицииДеб.ДатаДокумента;ПозицииДеб.НомерБум;ПозицииДеб.РеквП;ПозицииДеб.Т;ПозицииДеб.ВидЭд.ОКВЭД;ПозицииДеб.ВидЭд.Сумма";
    q.Filter = СложитьстрокиФильтраПоИ(aFiler);
    if q.Count > 0:
      --q.Order = "ПозицииДеб.ДатаДокумента;ПозицииДеб.РеквП;ПозицииДеб.НомерБум;ПозицииДеб.ВидЭд.ОКВЭД";
      q.Select;

--type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд, тПтОКВЭД);
--type тРезультатСравнения = (тМеньше = 1, тРавно, тБольше);
--
--var КодыЭД: variant[2] = [["62.01", тСумма6201], ["62.02", тСумма6202], ["62.09", тСумма6202], ["46.51", тСумма4651]];
--var ПоляПодтаблицы: string[] = ["ДатаДокумента", "РеквП", "НомерБум", "Сумма", "ВидЭд", "Сумма", "ОКВЭД"];

--proc ДобавитьВОтчет(мПозиция: variant[]);
----type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд);
      if not RecordEdited(Self.Record):
        ValidRecordEdit(Self.Record);
      fi;
      if RecordEdited(Self.Record):
        if Позиции.Count > 0:
          Позиции.Clear;
        fi;
        while not q.Eof do
          --locSub = q.Current.ПозицииДеб;
          for iter = 1 .. q.Current.ПозицииДеб.Count do
            for локКлонкаПодтаблицы = тПтДата .. тПтВидЭд do
             мПозиция[локКлонкаПодтаблицы] = q.Current.ПозицииДеб.Items[iter].GetField(ПоляПодтаблицы[локКлонкаПодтаблицы]);
            end;
            ДобавитьВОтчет(мПозиция);
          od;
          q.Next;
        od;
      else
        seterror(-1,"Не внести изменения в документ!", "Ошибка:", itError);
      fi;
    else
      message('Нет данных для занесения в регистр!');
    fi;
  finally
    q = nil;
  end;
--  if vartype(ares) = varArray and LengthOfArray(ares)>0:
--    if not RecordEdited(Self.Record):
--      ValidRecordEdit(Self.Record);
--    fi;
--    if RecordEdited(Self.Record):
--      if Позиции.Count > 0:
--        Позиции.Clear;
--      fi;
--      for iter = 1 .. LengthOfArray(ares[1]) do
----          locExtId = ares[1, iter];
----          locDate = ares[2, iter];
----          locNum = ares[3, iter];
----          locRekv = ares[4, iter];
----          locT = ares[5, iter];
--        if locDate <> ares[1, iter] or locNum <> ares[2, iter] or
--           locRekv <> ares[3, iter] or locT <> ares[4, iter]:
--          locExtId = ares[1, iter];
--          locDate = ares[2, iter];
--          locNum = ares[3, iter];
--          locRekv = ares[4, iter];
--          locT = ares[5, iter];
--          isub = Позиции.Count+1;
--          Позиции.Insert(isub);
--          Позиции[isub].БанковскаяВыписка =QueryRecord(Бухучет.Банки.Выписки, "ExtId='" + locExtId +"'");
--          Позиции[isub].Контрагент        =locRekv;
--          Позиции[isub].РеквП             =locRekv;
--          --Позиции[isub].ПрихПлатПоручение = nil;
--          --Позиции[isub].ПервДок           = nil;
--          --Позиции[isub].КорСчет           = nil;
--          --Позиции[isub].Банк              = nil;
--          --Позиции[isub].КодОп             = "";
--          --Позиции[isub].НомВыпД           = "";
--          Позиции[isub].ДатаДокумента     = locDate;
--          Позиции[isub].НомерБум          = locNum;
--          Позиции[isub].Т                 = locT;
--        fi;
--        with Позиции[isub].ВидЭД do
--          with Insert(Count + 1) do
--            ОКВЭД = ares[6, iter]; -- Позиции[isub].ВидЭД[].ОКВЭД
--            Сумма = ares[7, iter]; -- Позиции[isub].ВидЭД[].Сумма
--          od;
--        od;
--      od;
--    else
--      seterror(-1,"Не внести изменения в документ!", "Ошибка:", itError);
--    fi;
--  fi;
end;


--@doc получить величину для сравнения
func ДляСравнения(ПоКолонке: тКолонкиПодтаблицы; Значение: variant): variant;
  if ПоКолонке = тПтКонтрагент:
    if Значение <> nil:
      result = Значение.Имя;
    else
      result = "";
    fi;
  elsif ПоКолонке = тПтОКВЭД:
    if Значение <> nil:
      result = Значение.Код;
    else
      result = "";
    fi;
  else
    result = Значение;
  fi;
end;

--type тРезультатСравнения = (тМеньше = 1, тРавно, тБольше);
--var ПоляПодтаблицы: variant[2] = [["ДатаДокумента", тПтДата], ["РеквП", тПтКонтрагент], ["НомерБум", тПтНомер]];
--var ПоляПодтаблицы: string[] = ["ДатаДокумента", "РеквП", "НомерБум"];
--@doc сравнение поля подтаблицы со значением
func Сравнить(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; Индекс: integer): тРезультатСравнения;
  var ЗначениеИзПодтаблицы, ЗначениеПараметр: variant;
  if ПоКолонке = тПтОКВЭД:
    ЗначениеИзПодтаблицы = ДляСравнения(ПоКолонке, ВидЭД.Items[Индекс].GetField(ПоляПодтаблицы[ПоКолонке]));
  else
    ЗначениеИзПодтаблицы = ДляСравнения(ПоКолонке, Позиции.Items[Индекс].GetField(ПоляПодтаблицы[ПоКолонке]));
  fi;
  ЗначениеПараметр = ДляСравнения(ПоКолонке, Значение);
  if ЗначениеПараметр < ЗначениеИзПодтаблицы:
    return тМеньше;
  elsif ЗначениеПараметр = ЗначениеИзПодтаблицы:
    return тРавно;
  else
    return тБольше;
  fi;
end;

--var ПоляПодтаблицы: variant[2] = [["ДатаДокумента", тПтДата], ["РеквП", тПтКонтрагент], ["НомерБум", тПтНомер]];
--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение для сохранения упорядоченности
func НайтиБыстроВПодтаблице(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; от: integer; до: integer): Integer;
  var РезультатСравнения: тРезультатСравнения;
  var середина: integer;
  if до = 0:
    result = - 1;
  elsif от > до:
    result = - (до + 1);
  elsif от = до:
    РезультатСравнения = Сравнить(ПоКолонке, Значение, от);
    if РезультатСравнения = тМеньше:
      result = - от;
    elsif РезультатСравнения = тРавно:
      result = от;
    else
      result = - (от + 1);
    fi;
  elsif от + 1 = до:
    result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, от, от);
    if result < 0 and - result > от:
      result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, до, до);
    fi;
  else
    середина = от + int((до - от)/2);
    result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, от, середина);
    if result < 0 and - result > середина:
      result = НайтиБыстроВПодтаблице(ПоКолонке, Значение, середина + 1, до);
    fi;
  fi;
end;


--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение для сохранения упорядоченности
func НайтиВПодтаблице(ПоКолонке: тКолонкиПодтаблицы; Значение: variant; от: integer; до: integer): Integer;
  var iter: integer;
  var РезультатСравнения: тРезультатСравнения;
  iter = от;
  while iter <= до do
    РезультатСравнения = Сравнить(ПоКолонке, Значение, iter);
    if РезультатСравнения = тРавно:
      result = iter;
      break;
    elsif РезультатСравнения = тМеньше:
      result = - iter;
      break;
    fi;
    iter = iter + 1;
  od;
  if iter > до:
    result = - iter;
  fi;
end;

--@doc добавление данных в отчет
proc ДобавитьВОтчет(мПозиция: variant[]);
--type тКолонкиПодтаблицы = (тПтДата = 1, тПтКонтрагент, тПтНомер, тПтСуммаВсего, тПтВидЭд, тПтСуммаВидЭд);
  var iter: тКолонкиПодтаблицы;
  var index, ifrom, ito, indexsub, itersub: integer;
  var ЗначениеИзПодтаблицы: variant;
  ifrom = 1;
  ito = Позиции.Count;
  for iter = тПтДата .. тПтНомер do
    index = НайтиБыстроВПодтаблице(iter, мПозиция[iter], ifrom, ito);
    --index = НайтиВПодтаблице(iter, мПозиция[iter], ifrom, ito);
    if index < 0:
      break;
    else
      ЗначениеИзПодтаблицы = ДляСравнения(iter, Позиции.Items[index].GetField(ПоляПодтаблицы[iter]));
      ifrom = index;
      index = index + 1;
      while index <= ito  do
        if ЗначениеИзПодтаблицы <> ДляСравнения(iter, Позиции.Items[index].GetField(ПоляПодтаблицы[iter])):
          ito = index - 1;
          break;
        else
          index = index + 1;
        fi;
      od;
    fi;
  od;
  if index < 0:
    index = - index;
    Позиции.Insert(index);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтДата], мПозиция[тПтДата]);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтКонтрагент], мПозиция[тПтКонтрагент]);
    Позиции.Items[index].SetField(ПоляПодтаблицы[тПтНомер], мПозиция[тПтНомер]);
  fi;
  Позиции.Items[index].Сумма = Позиции.Items[index].Сумма + мПозиция[тПтСуммаВсего];
  ВидЭД = Позиции.Items[index].ВидЭД;
  for itersub = 1 .. мПозиция[тПтВидЭд].Count do
   indexsub = НайтиВПодтаблице(тПтОКВЭД, мПозиция[тПтВидЭд].Items[itersub].ОКВЭД, 1, ВидЭД.Count);
   if indexsub < 0:
     indexsub = - indexsub;
     ВидЭД.Insert(indexsub);
     ВидЭД.items[indexsub].ОКВЭД = мПозиция[тПтВидЭд].Items[itersub].ОКВЭД;
   fi;
   ВидЭД.items[indexsub].Сумма = ВидЭД.items[indexsub].Сумма + мПозиция[тПтВидЭд].Items[itersub].Сумма;
  od;
end;

---@doc распределение оКВЭД по колонкам отчета
proc РаспределитьОКВЭДпоКолонкам;
--var ВидыЭД: Классификаторы.ОКВЭД2[];
--type тКолонкиОтчета = (тДата = 1, тКонтрагент, тНомер, тСуммаВсего, тСумма6201, тСумма6202, тСумма6209, тСумма4651, тСуммаДР1, тСуммаДР2);
--КодыЭД[]
--  func QueryRecord(aClass :class Record; AFilter :String; AOrder :String = ""; AFields :String = "") :Record;
var locRec: Классификаторы.ОКВЭД2;
var iter: integer;
 РаспределениеВЭД = nil;
 for iter = 1 .. LengthOfArray(КодыЭД) do
   locRec = QueryRecord(Классификаторы.ОКВЭД2, format("КОД='%s'", [КодыЭД[iter, 1]]), , "DocId;GroupPath");
   if locRec <> nil:
     РаспределениеВЭД[locRec.DocId]= КодыЭД[iter, 2] as тКолонкиОтчета;
     with Query.Create([Классификаторы.ОКВЭД2]) do
       LoadingFields = "DocId";
       LoadingFieldsMode = mdNone;
       Filter = format("pos('%s%d.',GroupPath)=1",[locRec.GroupPath, locRec.DocId]);
       Select;
       while not Eof do
         РаспределениеВЭД[Current.DocId]= КодыЭД[iter, 2] as тКолонкиОтчета;
         next;
       od;
     end;
   fi;
 od;
end;

func ПолучитьСуммуПоВЭД(Index: integer; тКолонка: тКолонкиОтчета): Numeric;
  var iter: integer;
  var ВидЭД: SubTable;
  ВидЭД = Позиции.Items[index].ВидЭД;
  for iter = 1 .. ВидЭД.Count do
    if РаспределениеВЭД[ВидЭД.items[iter].ОКВЭД.DocID] = тКолонка:
      result = result + ВидЭД.items[iter].Сумма;
    fi;
  od;
end;

  proc шаблон_ПриОткрытии(Create :Logical);
    -- Вызывается при открытия окна формы
    --   Create: True - форма открывается, False - форма восстанавливается при запуске сессии
    if РаспределениеВЭД = nil:
      РаспределитьОКВЭДпоКолонкам;
    fi;
    inherited шаблон_ПриОткрытии(Create);
  end;

--}

--{ Обработчики событий бланка

--}

--{ Обработчики событий объектов бланка

proc кнРасчет(Sender :Button);
  if ПараметрыКорректны:
    Заполнитьбланк;
  fi;
end;

--}

--{ Обработчики событий полей бланка

func Поле_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  -- Обработка вывода значения поля в зависимости от типа события
  -- Параметры:
  --   Cell: клетка шаблона
  --   Value: значение в поле клетки
  --   Action: тип вывода (Вывод,Вычисление,Копирование,Экспорт)
  --   Format: строка-формат вывода значения
  if Cell.Contents in ["Сумма1", "Сумма2", "Сумма3", "Сумма4", "Сумма5"]:
    result = ПолучитьСуммуПоВЭД(Cell.Row, Cell.Column as тКолонкиОтчета);
  else
    Result = Value; -- Что получили, то и выводим
  fi;
end;

func ПолеПериодРасчета_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  if Cell.Contents = "Период.ДатаНачала":
    Cell.UseMacro = true;
    result = "c " + ДатаВСтрокуСМакро(Период.ДатаНачала);
  elsif Cell.Contents = "Период.ДатаОкончания":
    Cell.UseMacro = true;
    result = "по " + ДатаВСтрокуСМакро(Период.ДатаОкончания);
  else
    result = inherited ПолеПериодРасчета_ПриВыводе(Cell, Value, Action, Format);
  fi;
end;

func ПолеДата_ПриВыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  Cell.UseMacro = true;
  result = ДатаВСтрокуСМакро(Value);
end;
--}

end
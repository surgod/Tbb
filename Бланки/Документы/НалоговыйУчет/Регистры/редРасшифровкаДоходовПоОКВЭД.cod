class inherited Ќалог”чет.ƒокументы.Ќалоговый”чет.–егистры_јвтозаполнение.редЅазовый–егистр "–асшифровка доходов по ќ ¬Ёƒ", editor Ќалоговый”чет.–егистры.–асшифровкаƒоходовѕоќ ¬Ёƒ;
import —»—2 classes —троковые‘ункции,  алендарь, ‘ункцииƒокумента,  онстанты;

inclass private

type т олонкиќтчета = (тƒата = 1, т онтрагент, тЌомер, т—умма¬сего, т—умма6201, т—умма6202, т—умма6209, т—умма4651, т—уммаƒ–1, т—уммаƒ–2);
type т олонкиѕодтаблицы = (тѕтƒата = 1, тѕт онтрагент, тѕтЌомер, тѕт—умма¬сего, тѕт¬идЁд, тѕт—умма¬идЁд, тѕтќ ¬Ёƒ);
type т–езультат—равнени€ = (тћеньше = 1, т–авно, тЅольше);

var  одыЁƒ: variant[2] = [["62.01", т—умма6201], ["62.02", т—умма6202], ["62.09", т—умма6209], ["46.51", т—умма4651]];
var ѕол€ѕодтаблицы: string[] = ["ƒатаƒокумента", "–еквѕ", "ЌомерЅум", "—умма", "¬идЁд", "—умма", "ќ ¬Ёƒ"];
stored var “олько¬Ёƒ: logical;

inobject private

var —уммаѕоз: numeric[]; --

var –аспределение¬Ёƒ: т олонкиќтчета[]; -- распределение ¬Ёƒ по колонкам отчета

var ¬идЁƒ: Subtable; -- подтаблица видов Ёƒ

var —уммыѕо олонкам: variant[2];

--Ќалоговый”чет.–егистры.–асшифровкаƒоходовѕоќ ¬Ёƒ
--    struct ѕозиции array integer title "—писок операций";
--      field Ѕанковска€¬ыписка :Ѕухучет.Ѕанки.¬ыписки title "Ѕанковска€ выписка";
--      field  онтрагент        :Ѕазовый.ƒанные.—убъект title " онтрагент";
--      field –еквѕ             :Ѕазовый.ƒанные.—убъект title "–еквизиты контрагента";
--      field ѕрихѕлатѕоручение :ѕервичка.Ѕанки.ѕрихѕлѕоручени€ title "ѕрих.платежное поручение";
--      field ѕервƒок           :ѕервичка.Ѕанки.ѕрихѕлѕоручени€ title "ѕервичный документ";
--      field  ор—чет           :Ѕазовый.—правочники.Ѕанковские–еквизиты title "Ѕанковские реквизиты";
--      field Ѕанк              :Ѕазовый.—правочники.Ѕанковские–еквизиты title "Ѕанковские реквизиты";
--      field ƒатаƒокумента     :date title "ƒата первичного документа";
--      field ЌомерЅум          :string title "Ќомер, первичного документа";
--      field Ќом¬ыпƒ           :string title "Ќомер строки в выписке банка";
--      field “                 :string(350) title "Ќазначение платежа";
--      field —умма             :real title "—умма—умма операции";
--      field ќ ¬Ёƒ             : лассификаторы.ќ ¬Ёƒ2 title "ѕризнак ќ ¬Ёƒ";
--      field  одќп             :string title " орреспондирующий счет";
--   end;

--  struct ѕозицииƒеб array Integer;
--    field ѕроводить         :Logical                                 title "‘ормировать операцию по текущей позиции";
--    field Ќом¬ыпƒ           :String                                  title "Ќомер строки в выписке банка";
--
--    field ƒатаƒокумента     :Date                                    title "ƒата платежного документа";
--    field ЌомерЅум          :String                                  title "Ќомер, указанный в выписке банка";
--
--    field –еквѕ             :Ѕазовый.ƒанные.—убъект                  title "–еквизиты контрагента";
--    field —умма             :Numeric                                 title "—умма платежа";
--    field  одќп             :String                                  title " орреспондирующий счет";
--
--    field јв—чет‘актура     :ѕервичка.”четЌƒ—.—чета‘актуры;
--    field  ор—чет           :Ѕазовый.—правочники.Ѕанковские–еквизиты title "Ѕанковские реквизиты";
--    field “                 :String(350)                             title "Ќазначение платежа";
--
--    field ѕрихѕлатѕоручение :ѕервичка.Ѕанки.ѕрихѕлѕоручени€;
--
--    struct ƒопѕараметры array Integer;
--      field Ќазвание       :String;
--      field «начение       :inherited —»—2.Ѕазова€.Ѕазова€«апись;
--      field –асщепление    :Integer;
--    end;
--  end;

--{ вспомогательые методы
--@doc строковое представление даты в виде "__" ________ YY__  с макросами пол€
func ƒата¬—троку—ћакро(locDate:Date): string;
  result = format('"<u+>%d<u->" <u+>%s<u-> %d<u+>%d<u->',
                  [day(locDate), ћес€ца(Mon(locDate)), div(year(locDate), 100), mod(year(locDate), 100)]);
end;

--@doc проверка входных параметров
func ѕараметры орректны: logical;
  if –екв = nil:
  elsif ѕериод = nil:
   Message("”кажите отчетный период!");
   Self.Template.Field = "ѕериод.ƒатаЌачала";
  else
    result = true;
  fi;
end;

--@doc заполнение бланка
proc «аполнитьбланк;
  var q: Query;
  var iter: integer;
  --var iter, isub, irec: integer;
  var лок лонкаѕодтаблицы: т олонкиѕодтаблицы;
  var aFiler: string[];
  --var ares: variant[2];
  var мѕозици€: variant[];
  --var locDate: Date;
  --var locNum, locT, locExtId: string;
  --var locRekv: Ѕазовый.ƒанные.—убъект;
  --var locSub: structure;
  if –аспределение¬Ёƒ = nil:
    –аспределитьќ ¬Ёƒпо олонкам;
  fi;

  --ares = nil;


  aFiler[1] = "ѕроводить";
  --aFiler[2] = "ѕозицииƒеб.ѕроводить";
  aFiler[3] = "ƒатаѕроведени€>01.01.1900";
--  --aFiler[4] = "ѕозицииƒеб.ƒата>=" + str(ѕериод.ƒатаЌачала);
--  --aFiler[5] = "ѕозицииƒеб.ƒата<=" + str(ѕериод.ƒатаќкончани€);
  aFiler[4] = "ƒатаѕроведени€>=" + str(ѕериод.ƒатаЌачала);
  aFiler[5] = "ƒатаѕроведени€<=" + str(ѕериод.ƒатаќкончани€);
  aFiler[6] = "–екв=" + str(–екв);
  q = Query.Create([Ѕухучет.Ѕанки.¬ыписки]);
  try
    q.LoadingFieldsMode = mdAll + mdStructArrays;
    q.LoadingFields = "ExtId;ѕроводить;ƒатаѕроведени€;–екв;ѕозицииƒеб;ѕозицииƒеб.ѕроводить;ѕозицииƒеб.ƒатаƒокумента;ѕозицииƒеб.ЌомерЅум;ѕозицииƒеб.–еквѕ;ѕозицииƒеб.“;ѕозицииƒеб.¬идЁд.ќ ¬Ёƒ;ѕозицииƒеб.¬идЁд.—умма";
    q.Filter = —ложитьстроки‘ильтраѕо»(aFiler);
    if q.Count > 0:
      --q.Order = "ѕозицииƒеб.ƒатаƒокумента;ѕозицииƒеб.–еквѕ;ѕозицииƒеб.ЌомерЅум;ѕозицииƒеб.¬идЁд.ќ ¬Ёƒ";
      q.Select;

--type т олонкиѕодтаблицы = (тѕтƒата = 1, тѕт онтрагент, тѕтЌомер, тѕт—умма¬сего, тѕт¬идЁд, тѕт—умма¬идЁд, тѕтќ ¬Ёƒ);
--type т–езультат—равнени€ = (тћеньше = 1, т–авно, тЅольше);
--
--var  одыЁƒ: variant[2] = [["62.01", т—умма6201], ["62.02", т—умма6202], ["62.09", т—умма6202], ["46.51", т—умма4651]];
--var ѕол€ѕодтаблицы: string[] = ["ƒатаƒокумента", "–еквѕ", "ЌомерЅум", "—умма", "¬идЁд", "—умма", "ќ ¬Ёƒ"];

--proc ƒобавить¬ќтчет(мѕозици€: variant[]);
----type т олонкиѕодтаблицы = (тѕтƒата = 1, тѕт онтрагент, тѕтЌомер, тѕт—умма¬сего, тѕт¬идЁд, тѕт—умма¬идЁд);
      if not RecordEdited(Self.Record):
        ValidRecordEdit(Self.Record);
      fi;
      if RecordEdited(Self.Record):
        if ѕозиции.Count > 0:
          ѕозиции.Clear;
        fi;
        while not q.Eof do
          --locSub = q.Current.ѕозицииƒеб;
          for iter = 1 .. q.Current.ѕозицииƒеб.Count do
            for лок лонкаѕодтаблицы = тѕтƒата .. тѕт¬идЁд do
             мѕозици€[лок лонкаѕодтаблицы] = q.Current.ѕозицииƒеб.Items[iter].GetField(ѕол€ѕодтаблицы[лок лонкаѕодтаблицы]);
            end;
            if not “олько¬Ёƒ or мѕозици€[тѕт¬идЁд].count > 0:
              ƒобавить¬ќтчет(мѕозици€);
            fi;
          od;
          q.Next;
        od;
      else
        seterror(-1,"Ќе внести изменени€ в документ!", "ќшибка:", itError);
      fi;
    else
      message('Ќет данных дл€ занесени€ в регистр!');
    fi;
  finally
    q = nil;
  end;
  ѕолучить—уммыѕо олонкам;
--  if “олько¬Ёƒ:
--    iter = 1;
--    while  iter <= ѕозиции.Count do
--      if ¬з€ть—уммуѕоколонкам(iter) = 0:
--        ѕозиции.delete(iter);
--        locSub = ѕозиции.items[iter];
--      else
--        iter = iter + 1;
--      fi;
--    od;
--  fi;

--  if vartype(ares) = varArray and LengthOfArray(ares)>0:
--    if not RecordEdited(Self.Record):
--      ValidRecordEdit(Self.Record);
--    fi;
--    if RecordEdited(Self.Record):
--      if ѕозиции.Count > 0:
--        ѕозиции.Clear;
--      fi;
--      for iter = 1 .. LengthOfArray(ares[1]) do
----          locExtId = ares[1, iter];
----          locDate = ares[2, iter];
----          locNum = ares[3, iter];
----          locRekv = ares[4, iter];
----          locT = ares[5, iter];
--        if locDate <> ares[1, iter] or locNum <> ares[2, iter] or
--           locRekv <> ares[3, iter] or locT <> ares[4, iter]:
--          locExtId = ares[1, iter];
--          locDate = ares[2, iter];
--          locNum = ares[3, iter];
--          locRekv = ares[4, iter];
--          locT = ares[5, iter];
--          isub = ѕозиции.Count+1;
--          ѕозиции.Insert(isub);
--          ѕозиции[isub].Ѕанковска€¬ыписка =QueryRecord(Ѕухучет.Ѕанки.¬ыписки, "ExtId='" + locExtId +"'");
--          ѕозиции[isub]. онтрагент        =locRekv;
--          ѕозиции[isub].–еквѕ             =locRekv;
--          --ѕозиции[isub].ѕрихѕлатѕоручение = nil;
--          --ѕозиции[isub].ѕервƒок           = nil;
--          --ѕозиции[isub]. ор—чет           = nil;
--          --ѕозиции[isub].Ѕанк              = nil;
--          --ѕозиции[isub]. одќп             = "";
--          --ѕозиции[isub].Ќом¬ыпƒ           = "";
--          ѕозиции[isub].ƒатаƒокумента     = locDate;
--          ѕозиции[isub].ЌомерЅум          = locNum;
--          ѕозиции[isub].“                 = locT;
--        fi;
--        with ѕозиции[isub].¬идЁƒ do
--          with Insert(Count + 1) do
--            ќ ¬Ёƒ = ares[6, iter]; -- ѕозиции[isub].¬идЁƒ[].ќ ¬Ёƒ
--            —умма = ares[7, iter]; -- ѕозиции[isub].¬идЁƒ[].—умма
--          od;
--        od;
--      od;
--    else
--      seterror(-1,"Ќе внести изменени€ в документ!", "ќшибка:", itError);
--    fi;
--  fi;
end;


--@doc получить величину дл€ сравнени€
func ƒл€—равнени€(ѕо олонке: т олонкиѕодтаблицы; «начение: variant): variant;
  if ѕо олонке = тѕт онтрагент:
    if «начение <> nil:
      result = «начение.»м€;
    else
      result = "";
    fi;
  elsif ѕо олонке = тѕтќ ¬Ёƒ:
    if «начение <> nil:
      result = «начение. од;
    else
      result = "";
    fi;
  else
    result = «начение;
  fi;
end;

--@doc сравнение пол€ подтаблицы со значением
func —равнить(ѕо олонке: т олонкиѕодтаблицы; «начение: variant; »ндекс: integer): т–езультат—равнени€;
  var «начение»зѕодтаблицы, «начениеѕараметр: variant;
  if ѕо олонке = тѕтќ ¬Ёƒ:
    «начение»зѕодтаблицы = ƒл€—равнени€(ѕо олонке, ¬идЁƒ.Items[»ндекс].GetField(ѕол€ѕодтаблицы[ѕо олонке]));
  else
    «начение»зѕодтаблицы = ƒл€—равнени€(ѕо олонке, ѕозиции.Items[»ндекс].GetField(ѕол€ѕодтаблицы[ѕо олонке]));
  fi;
  «начениеѕараметр = ƒл€—равнени€(ѕо олонке, «начение);
  if «начениеѕараметр < «начение»зѕодтаблицы:
    return тћеньше;
  elsif «начениеѕараметр = «начение»зѕодтаблицы:
    return т–авно;
  else
    return тЅольше;
  fi;
end;

--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение дл€ сохранени€ упор€доченности
func ЌайтиЅыстро¬ѕодтаблице(ѕо олонке: т олонкиѕодтаблицы; «начение: variant; от: integer; до: integer): Integer;
  var –езультат—равнени€: т–езультат—равнени€;
  var середина: integer;
  if до = 0:
    result = - 1;
  elsif от > до:
    result = - (до + 1);
  elsif от = до:
    –езультат—равнени€ = —равнить(ѕо олонке, «начение, от);
    if –езультат—равнени€ = тћеньше:
      result = - от;
    elsif –езультат—равнени€ = т–авно:
      result = от;
    else
      result = - (от + 1);
    fi;
  elsif от + 1 = до:
    result = ЌайтиЅыстро¬ѕодтаблице(ѕо олонке, «начение, от, от);
    if result < 0 and - result > от:
      result = ЌайтиЅыстро¬ѕодтаблице(ѕо олонке, «начение, до, до);
    fi;
  else
    середина = от + int((до - от)/2);
    result = ЌайтиЅыстро¬ѕодтаблице(ѕо олонке, «начение, от, середина);
    if result < 0 and - result > середина:
      result = ЌайтиЅыстро¬ѕодтаблице(ѕо олонке, «начение, середина + 1, до);
    fi;
  fi;
end;

--@doc поиск строки в подтаблице: возвращает номер позиции, если найдено, или -отриательный номер позици, в которую надо вставить
--@doc новое значение дл€ сохранени€ упор€доченности
func Ќайти¬ѕодтаблице(ѕо олонке: т олонкиѕодтаблицы; «начение: variant; от: integer; до: integer): Integer;
  var iter: integer;
  var –езультат—равнени€: т–езультат—равнени€;
  iter = от;
  while iter <= до do
    –езультат—равнени€ = —равнить(ѕо олонке, «начение, iter);
    if –езультат—равнени€ = т–авно:
      result = iter;
      break;
    elsif –езультат—равнени€ = тћеньше:
      result = - iter;
      break;
    fi;
    iter = iter + 1;
  od;
  if iter > до:
    result = - iter;
  fi;
end;

--@doc добавление данных в отчет
proc ƒобавить¬ќтчет(мѕозици€: variant[]);
--type т олонкиѕодтаблицы = (тѕтƒата = 1, тѕт онтрагент, тѕтЌомер, тѕт—умма¬сего, тѕт¬идЁд, тѕт—умма¬идЁд);
  var iter: т олонкиѕодтаблицы;
  var index, ifrom, ito, indexsub, itersub: integer;
  var «начение»зѕодтаблицы: variant;
  ifrom = 1;
  ito = ѕозиции.Count;
  for iter = тѕтƒата .. тѕтЌомер do
    index = ЌайтиЅыстро¬ѕодтаблице(iter, мѕозици€[iter], ifrom, ito);
    --index = Ќайти¬ѕодтаблице(iter, мѕозици€[iter], ifrom, ito);
    if index < 0:
      break;
    else
      «начение»зѕодтаблицы = ƒл€—равнени€(iter, ѕозиции.Items[index].GetField(ѕол€ѕодтаблицы[iter]));
      ifrom = index;
      index = index + 1;
      while index <= ito  do
        if «начение»зѕодтаблицы <> ƒл€—равнени€(iter, ѕозиции.Items[index].GetField(ѕол€ѕодтаблицы[iter])):
          ito = index - 1;
          break;
        else
          index = index + 1;
        fi;
      od;
    fi;
  od;
  if index < 0:
    index = - index;
    ѕозиции.Insert(index);
    ѕозиции.Items[index].SetField(ѕол€ѕодтаблицы[тѕтƒата], мѕозици€[тѕтƒата]);
    ѕозиции.Items[index].SetField(ѕол€ѕодтаблицы[тѕт онтрагент], мѕозици€[тѕт онтрагент]);
    ѕозиции.Items[index].SetField(ѕол€ѕодтаблицы[тѕтЌомер], мѕозици€[тѕтЌомер]);
  fi;
  ѕозиции.Items[index].—умма = ѕозиции.Items[index].—умма + мѕозици€[тѕт—умма¬сего];
  ¬идЁƒ = ѕозиции.Items[index].¬идЁƒ;
  for itersub = 1 .. мѕозици€[тѕт¬идЁд].Count do
   indexsub = Ќайти¬ѕодтаблице(тѕтќ ¬Ёƒ, мѕозици€[тѕт¬идЁд].Items[itersub].ќ ¬Ёƒ, 1, ¬идЁƒ.Count);
   if indexsub < 0:
     indexsub = - indexsub;
     ¬идЁƒ.Insert(indexsub);
     ¬идЁƒ.items[indexsub].ќ ¬Ёƒ = мѕозици€[тѕт¬идЁд].Items[itersub].ќ ¬Ёƒ;
   fi;
   ¬идЁƒ.items[indexsub].—умма = ¬идЁƒ.items[indexsub].—умма + мѕозици€[тѕт¬идЁд].Items[itersub].—умма;
  od;
end;

---@doc распределение о ¬Ёƒ по колонкам отчета
proc –аспределитьќ ¬Ёƒпо олонкам;
var locRec:  лассификаторы.ќ ¬Ёƒ2;
var iter: integer;
 –аспределение¬Ёƒ = nil;
 for iter = 1 .. LengthOfArray( одыЁƒ) do
   locRec = QueryRecord( лассификаторы.ќ ¬Ёƒ2, format(" ќƒ='%s'", [ одыЁƒ[iter, 1]]), , "DocId;GroupPath");
   if locRec <> nil:
     –аспределение¬Ёƒ[locRec.DocId]=  одыЁƒ[iter, 2] as т олонкиќтчета;
     with Query.Create([ лассификаторы.ќ ¬Ёƒ2]) do
       LoadingFields = "DocId";
       LoadingFieldsMode = mdNone;
       Filter = format("pos('%s%d.',GroupPath)=1",[locRec.GroupPath, locRec.DocId]);
       Select;
       while not Eof do
         –аспределение¬Ёƒ[Current.DocId]=  одыЁƒ[iter, 2] as т олонкиќтчета;
         next;
       od;
     end;
   fi;
 od;
end;

func ѕолучить—уммуѕо¬Ёƒ(Index: integer; т олонка: т олонкиќтчета): Numeric;
  var iter: integer;
  var ¬идЁƒ: SubTable;
  if VarType(—уммыѕо олонкам[index, т олонка]) <> varNumeric:
    ¬идЁƒ = ѕозиции.Items[index].¬идЁƒ;
    for iter = 1 .. ¬идЁƒ.Count do
      if т олонка <> т—уммаƒ–1:
        if –аспределение¬Ёƒ[¬идЁƒ.items[iter].ќ ¬Ёƒ.DocID] = т олонка:
          result = result + ¬идЁƒ.items[iter].—умма;
        fi;
      elsif –аспределение¬Ёƒ[¬идЁƒ.items[iter].ќ ¬Ёƒ.DocID] = nil:
        result = result + ¬идЁƒ.items[iter].—умма;
      fi;
    od;
    —уммыѕо олонкам[index, т олонка] = result;
  else
   result = —уммыѕо олонкам[index, т олонка];
  fi;
end;

func ѕроверить—уммыѕо олонке(т олонка: т олонкиќтчета): logical;
  var index: integer;
  result = true;
  for index = 1 .. ѕозиции.Count do
    if VarType(—уммыѕо олонкам[index, т олонка]) <> varNumeric:
      result = false;
      break;
    fi;
  od;
end;

proc ѕолучить—уммыѕо олонке(т олонка: т олонкиќтчета);
  var index: integer;
  for index = 1 .. ѕозиции.Count do
    ѕолучить—уммуѕо¬Ёƒ(index, т олонка);
  od;
end;

proc ѕолучить—уммыѕо олонкам;
  var т олонка: т олонкиќтчета;
  var index: integer;
  —уммыѕо олонкам = nil;
  for index = 1 .. ѕозиции.Count do
    for т олонка = т—умма6201 .. т—уммаƒ–1 do
      ѕолучить—уммуѕо¬Ёƒ(index, т олонка);
    od;
  od;
end;

func ¬з€ть—умму¬сегоѕо олонке(т олонка: т олонкиќтчета): numeric;
  if not ѕроверить—уммыѕо олонке(т олонка):
    ѕолучить—уммыѕо олонке(т олонка);
  fi;
  result = sumofarray(—уммыѕо олонкам, ,[т олонка as integer]);
end;

func ¬з€тьѕроц¬сегоѕо олонке(т олонка: т олонкиќтчета): numeric;
  var т“ек ол: т олонкиќтчета;
  var лок—умма¬сего, лок—умма ол, лок—умма: numeric;
  for т“ек ол = т—умма6201 .. т—уммаƒ–1 do
    лок—умма = ¬з€ть—умму¬сегоѕо олонке(т“ек ол);
    лок—умма¬сего = лок—умма¬сего + лок—умма;
    if т“ек ол = т олонка:
      лок—умма ол = лок—умма;
    fi;
  od;
  if лок—умма¬сего <> 0:
   result = лок—умма ол / лок—умма¬сего * 100;
  else
    result = 0;
  fi;
end;

func ¬з€ть—уммуѕо олонкам(index: integer): numeric;
  var т“ек ол: т олонкиќтчета;
  for т“ек ол = т—умма6201 .. т—уммаƒ–1 do
    result = ѕолучить—уммуѕо¬Ёƒ(index, т“ек ол) + result;
  od;
end;

func ¬з€ть—умму¬сегоѕо олонкам: numeric;
  var т“ек ол: т олонкиќтчета;
  for т“ек ол = т—умма6201 .. т—уммаƒ–1 do
    result = ¬з€ть—умму¬сегоѕо олонке(т“ек ол) + result;
  od;
end;

--@ очистка вспомогательных массивов
proc ќчиститьƒоп;
 —уммыѕо олонкам = nil;
end;

--}

--{ ќбработчики событий бланка

  proc шаблон_ѕриќткрытии(Create :Logical);
    if –аспределение¬Ёƒ = nil:
      –аспределитьќ ¬Ёƒпо олонкам;
    fi;
    ѕолучить—уммыѕо олонкам;
    inherited шаблон_ѕриќткрытии(Create);
  end;

--}

--{ ќбработчики событий объектов бланка

proc кн–асчет(Sender :Button);
  if ѕараметры орректны:
    «аполнитьбланк;
  fi;
end;

--}

--{ ќбработчики событий полей бланка

func ѕолеѕериод–асчета_ѕриѕроверке(Cell :TemplateCell; Index :Integer;
  var Value :Variant) :Logical;
  Result = inherited ѕолеѕериод–асчета_ѕриѕроверке(Cell, Index, Value);
  if ѕериод <> value and ѕозиции.Count = 0:
    ќчиститьƒоп;
  fi;
end;

func ѕоле_ѕри¬ыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  if Cell.Contents in ["—умма1", "—умма2", "—умма3", "—умма4", "—умма5"]:
    result = ѕолучить—уммуѕо¬Ёƒ(Cell.Row, Cell.Column as т олонкиќтчета);
  elsif Cell.Contents in ["—умма¬сего1", "—умма¬сего2", "—умма¬сего3", "—умма¬сего4", "—умма¬сего5"]:
--    if not ѕроверить—уммыѕо олонке(Cell.Column as т олонкиќтчета):
--      ѕолучить—уммыѕо олонке(Cell.Column as т олонкиќтчета);
--    fi;
--    result = sumofarray(—уммыѕо олонкам, ,[Cell.Column]);
    result = ¬з€ть—умму¬сегоѕо олонке(Cell.Column as т олонкиќтчета);
  elsif Cell.Contents = "—умма¬сего":
    result = ѕозиции.SumOfField("—умма");
  elsif Cell.Contents in ["ѕроц¬сего1", "ѕроц¬сего2", "ѕроц¬сего3", "ѕроц¬сего4", "ѕроц¬сего5"]:
    result = ¬з€тьѕроц¬сегоѕо олонке(Cell.Column as т олонкиќтчета);
  else
    Result = Value; -- „то получили, то и выводим
  fi;
end;

func ѕолеѕериод–асчета_ѕри¬ыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  if Cell.Contents = "ѕериод.ƒатаЌачала":
    Cell.UseMacro = true;
    result = "c " + ƒата¬—троку—ћакро(ѕериод.ƒатаЌачала);
  elsif Cell.Contents = "ѕериод.ƒатаќкончани€":
    Cell.UseMacro = true;
    result = "по " + ƒата¬—троку—ћакро(ѕериод.ƒатаќкончани€);
  else
    result = inherited ѕолеѕериод–асчета_ѕри¬ыводе(Cell, Value, Action, Format);
  fi;
end;

func ѕолеƒата_ѕри¬ыводе(Cell :TemplateCell; Value :Variant;
  Action :Template.OutputTypes; var Format :String) :Variant;
  Cell.UseMacro = true;
  result = ƒата¬—троку—ћакро(Value);
end;

proc ѕолеѕри–исовании(Cell :TemplateCell; Selected :Logical;
  var Color :Integer; var FieldColor :Integer; Font :Font);
  if Cell.Contents = "—умма":
    if ѕозиции.items[Cell.Row].—умма <> ¬з€ть—уммуѕо олонкам(Cell.Row):
      font.Color = —»—2. онстанты.clRed;
      font.Bold = true;
    fi;
  elsif Cell.Contents = "—умма¬сего":
    if round(ѕозиции.SumOfField("—умма"),2) <> round(¬з€ть—умму¬сегоѕо олонкам,2):
    --if ѕозиции.SumOfField("—умма") <> ¬з€ть—умму¬сегоѕо олонкам:
--      trace("¬з€ть—умму¬сегоѕо олонкам=" + str(¬з€ть—умму¬сегоѕо олонкам,"#.000000"));
--      trace("ѕозиции.SumOfField(—умма)=" + str(ѕозиции.SumOfField("—умма"),"#.000000"));
      font.Color = —»—2. онстанты.clRed;
      font.Bold = true;
    fi;
  fi;
end;

--}

end